---
phase: 03-script-blocking-form-gating
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/Providers/Providers.tsx
  - src/app/contact/page.tsx
  - src/components/ContactForm/ContactForm.tsx
  - src/components/ContactForm/ContactForm.module.css
autonomous: true

must_haves:
  truths:
    - "When user declines cookies, no reCAPTCHA or FingerprintJS scripts appear in browser Network tab"
    - "When user accepts cookies, GoogleReCaptchaProvider mounts and reCAPTCHA scripts load on the contact page"
    - "When user declines cookies, contact page shows email link alternative instead of the form"
    - "When user accepts cookies, contact form loads with full reCAPTCHA and FingerprintJS spam prevention"
    - "Application does not crash when executeRecaptcha context is absent (provider not mounted)"
  artifacts:
    - path: "src/components/Providers/Providers.tsx"
      provides: "App-wide providers WITHOUT GoogleReCaptchaProvider"
      contains: "ToastContainer"
    - path: "src/app/contact/page.tsx"
      provides: "Contact page with consent-gated reCAPTCHA provider"
      contains: "useConsentStore"
    - path: "src/components/ContactForm/ContactForm.tsx"
      provides: "Consent-branching contact form with no-consent alternative"
      contains: "NoConsentAlternative"
    - path: "src/components/ContactForm/ContactForm.module.css"
      provides: "Styles for no-consent alternative UI"
      contains: "alternative"
  key_links:
    - from: "src/app/contact/page.tsx"
      to: "GoogleReCaptchaProvider"
      via: "conditional mount when hasConsented === true"
      pattern: "hasConsented === true.*GoogleReCaptchaProvider"
    - from: "src/components/ContactForm/ContactForm.tsx"
      to: "useConsentStore"
      via: "reads hasConsented to branch between full form and no-consent alternative"
      pattern: "hasConsented.*false.*NoConsentAlternative"
    - from: "src/hooks/useContactForm.ts"
      to: "useGoogleReCaptcha"
      via: "called only inside ContactFormFull which renders within provider tree"
      pattern: "useGoogleReCaptcha"
---

<objective>
Gate reCAPTCHA and FingerprintJS behind cookie consent, and replace the contact form with an email alternative when consent is declined.

Purpose: Enforce GDPR compliance by ensuring third-party tracking scripts (reCAPTCHA, FingerprintJS) never load before user consent, and provide a functional alternative (email link) when the user declines cookies — avoiding cookie-walling.

Output: Modified Providers.tsx (no longer wraps app in GoogleReCaptchaProvider), consent-gated provider on contact page, consent-branching ContactForm with no-consent alternative UI.
</objective>

<execution_context>
@/Users/zachshearer/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zachshearer/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-script-blocking-form-gating/03-RESEARCH.md
@.planning/phases/01-state-management-foundation/01-01-SUMMARY.md
@.planning/phases/02-banner-ui-user-controls/02-01-SUMMARY.md
@src/components/Providers/Providers.tsx
@src/app/contact/page.tsx
@src/components/ContactForm/ContactForm.tsx
@src/components/ContactForm/ContactForm.module.css
@src/hooks/useContactForm.ts
@src/store/consentStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Remove GoogleReCaptchaProvider from Providers.tsx and gate it on the contact page</name>
  <files>src/components/Providers/Providers.tsx, src/app/contact/page.tsx</files>
  <action>
**Providers.tsx** — Remove GoogleReCaptchaProvider:
1. Remove the `import { GoogleReCaptchaProvider } from 'react-google-recaptcha-v3'` import
2. Remove the `siteKey` variable and the `if (!siteKey) throw` guard
3. Replace the JSX: instead of wrapping `{children}` and `ToastContainer` in `GoogleReCaptchaProvider`, wrap them in a React Fragment `<>...</>`
4. Keep `'use client'`, `ToastContainer` import, CSS import, and all ToastContainer props unchanged

After edit, Providers.tsx should look like:
```tsx
'use client';

import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';

export default function Providers({ children }: { children: React.ReactNode }) {
  return (
    <>
      {children}
      <ToastContainer
        position="bottom-right"
        autoClose={4000}
        hideProgressBar={false}
        newestOnTop={false}
        closeOnClick
        rtl={false}
        pauseOnFocusLoss
        draggable
        pauseOnHover
        theme="light"
      />
    </>
  );
}
```

**contact/page.tsx** — Add consent-gated reCAPTCHA provider:
1. Convert to a client component by adding `'use client'` at the top (needed to call `useConsentStore`)
2. Import `useConsentStore` from `@/store/consentStore`
3. Import `GoogleReCaptchaProvider` from `react-google-recaptcha-v3`
4. Read `hasConsented` and `isHydrated` from `useConsentStore()`
5. Determine whether to mount the provider: `const shouldMountProvider = isHydrated && hasConsented === true`
6. Get the site key: `const siteKey = process.env.NEXT_PUBLIC_RECAPTCHA_SITE_KEY`
7. Conditionally wrap `<ContactForm />` with `<GoogleReCaptchaProvider reCaptchaKey={siteKey!}>` ONLY when `shouldMountProvider && siteKey` is true. When false, render `<ContactForm />` without a provider wrapper.
8. Keep Header and Footer imports and rendering unchanged — they do NOT go inside the provider

The contact page structure should be:
```tsx
'use client';

import { GoogleReCaptchaProvider } from 'react-google-recaptcha-v3';
import { Header } from '@/components/Header';
import { ContactForm } from '@/components/ContactForm';
import { Footer } from '@/components/Footer';
import { useConsentStore } from '@/store/consentStore';

export default function ContactPage() {
  const { hasConsented, isHydrated } = useConsentStore();
  const shouldMountProvider = isHydrated && hasConsented === true;
  const siteKey = process.env.NEXT_PUBLIC_RECAPTCHA_SITE_KEY;

  return (
    <>
      <Header />
      {shouldMountProvider && siteKey ? (
        <GoogleReCaptchaProvider reCaptchaKey={siteKey}>
          <ContactForm />
        </GoogleReCaptchaProvider>
      ) : (
        <ContactForm />
      )}
      <Footer />
    </>
  );
}
```

**Why this approach:** Research confirmed (03-RESEARCH.md) that placing the provider at the contact page level is preferred over the global Providers.tsx because reCAPTCHA is only used by the contact form. This scopes the provider tightly and avoids mounting it on every page. The `shouldMountProvider` flag ensures no scripts load before hydration completes and consent is explicitly given.

**IMPORTANT:** Do NOT create a separate ConsentGate component — the conditional is simple enough to inline at the page level. This avoids an extra file and keeps the provider placement obvious.
  </action>
  <verify>
1. Run `npm run lint` — no ESLint errors
2. Confirm Providers.tsx has NO GoogleReCaptchaProvider import or usage
3. Confirm contact/page.tsx has `'use client'` directive, imports GoogleReCaptchaProvider, reads consent store, and conditionally wraps ContactForm
  </verify>
  <done>
Providers.tsx no longer wraps the app in GoogleReCaptchaProvider. The contact page conditionally mounts GoogleReCaptchaProvider around ContactForm only when isHydrated is true AND hasConsented is true. No reCAPTCHA scripts load on any page until consent is given, and they only load on the contact page.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add consent branching to ContactForm with no-consent alternative UI</name>
  <files>src/components/ContactForm/ContactForm.tsx, src/components/ContactForm/ContactForm.module.css</files>
  <action>
**ContactForm.tsx** — Add consent branching:

The critical constraint from research: `useContactForm` internally calls `useGoogleReCaptcha()`. When called outside a mounted `GoogleReCaptchaProvider`, `executeRecaptcha` is a **throwing function** (not undefined). The Rules of Hooks prevent calling hooks conditionally. Therefore, split into two internal components.

1. Rename the current `ContactForm` default export function to `ContactFormFull` (keep it in the same file — no separate file needed). This component calls `useContactForm()` and renders the full form JSX (all existing form markup).

2. Create a `NoConsentAlternative` function component in the same file:
   - Import `Link` from `next/link`
   - Import `useConsentStore` from `@/store/consentStore`
   - Call `const { clearConsent } = useConsentStore()` to get the re-consent action
   - Render: a section with `styles.contactSection`, containing a div with `styles.container`, an h2 "Contact Us" with `styles.title`, a subtitle paragraph explaining cookies are needed for spam prevention, and a div with `styles.alternative` containing:
     - A paragraph with "Email us directly: " followed by an `<a href="mailto:hello@streetfeastapp.com">` link styled with `styles.emailLink`
     - A paragraph with `styles.consentPrompt` containing: "Or " + a `<button onClick={clearConsent}>` styled with `styles.consentButton` that says "update your cookie preferences" + " to enable the contact form. By accepting, you agree to our " + `<Link href="/terms">Terms of Service</Link>` + "."
   - The `clearConsent` call resets hasConsented to null, which triggers the CookieBanner to reappear (Phase 2 built this)

3. Create a new default export `ContactForm` component that branches:
   - Import `useConsentStore` from `@/store/consentStore`
   - Read `{ hasConsented, isHydrated }` from `useConsentStore()`
   - If `!isHydrated || hasConsented !== false`: render `<ContactFormFull />` (optimistic — show form before hydration and when consent is true or null; scripts only load when provider is mounted via Task 1)
   - If `isHydrated && hasConsented === false`: render `<NoConsentAlternative />`

The full file structure should be:
```tsx
'use client';

import Link from 'next/link';
import styles from './ContactForm.module.css';
import { useContactForm } from '@/hooks/useContactForm';
import { useConsentStore } from '@/store/consentStore';

function ContactFormFull() {
  const { formData, status, handleChange, handleSubmit } = useContactForm();
  // ... existing full form JSX (all current markup from ContactForm)
}

function NoConsentAlternative() {
  const { clearConsent } = useConsentStore();
  // ... no-consent alternative UI as described above
}

export default function ContactForm() {
  const { hasConsented, isHydrated } = useConsentStore();

  if (!isHydrated || hasConsented !== false) {
    return <ContactFormFull />;
  }

  return <NoConsentAlternative />;
}
```

**ContactForm.module.css** — Add no-consent alternative styles:

Add these new classes AFTER the existing `.errorMessage` block and BEFORE the `@media (max-width: 1024px)` media query:

```css
/* No-consent alternative */
.alternative {
  text-align: center;
  padding: 2rem 0;
}

.alternative p {
  font-size: 1.125rem;
  color: #636363;
  line-height: 1.6;
  margin: 0 0 1.5rem 0;
}

.alternative p:last-child {
  margin-bottom: 0;
}

.emailLink {
  color: #ED6A00;
  font-weight: 600;
  text-decoration: none;
  transition: color 0.2s ease;
}

.emailLink:hover {
  color: #F2974D;
  text-decoration: underline;
}

.consentPrompt {
  font-size: 1rem;
  color: #808080;
}

.consentButton {
  background: none;
  border: none;
  color: #ED6A00;
  font-weight: 600;
  font-size: inherit;
  font-family: inherit;
  cursor: pointer;
  padding: 0;
  text-decoration: underline;
  transition: color 0.2s ease;
}

.consentButton:hover {
  color: #F2974D;
}
```

Also add responsive overrides for the alternative in each existing media query:

In `@media (max-width: 768px)`:
```css
.alternative p {
  font-size: 1rem;
}

.consentPrompt {
  font-size: 0.875rem;
}
```

In `@media (max-width: 480px)`:
```css
.alternative {
  padding: 1.5rem 0;
}

.alternative p {
  font-size: 0.875rem;
}

.consentPrompt {
  font-size: 0.8rem;
}
```

**Why this structure:** The research (03-RESEARCH.md Pitfall 3) specifically warns that `useContactForm` calls `useGoogleReCaptcha()` which MUST be inside a provider tree. By splitting into `ContactFormFull` (which uses the hook) and `NoConsentAlternative` (which doesn't), we ensure the hook is only called when the provider is mounted. The outer `ContactForm` branches between them based on consent state. The `!isHydrated` case renders `ContactFormFull` optimistically — no scripts load during SSR anyway, and the form is visible while the user decides (CookieBanner is showing).

**FingerprintJS handling (SCRP-02):** No changes needed to `useContactForm.ts`. FingerprintJS is already lazy-loaded inside `handleSubmit` (only runs at submit time). When `hasConsented === false`, the form isn't rendered, so `handleSubmit` can never fire. When `hasConsented === null`, `executeRecaptcha` check fails first, aborting before FingerprintJS loads. When `hasConsented === true`, both reCAPTCHA and FingerprintJS work normally.
  </action>
  <verify>
1. Run `npm run lint` — no ESLint errors
2. Confirm ContactForm.tsx exports default `ContactForm` that branches on consent
3. Confirm `ContactFormFull` calls `useContactForm` (with `useGoogleReCaptcha` internally)
4. Confirm `NoConsentAlternative` has mailto link, clearConsent button, and Terms of Service link
5. Confirm ContactForm.module.css has `.alternative`, `.emailLink`, `.consentButton`, `.consentPrompt` classes
6. Run `npm run build` — no build errors
  </verify>
  <done>
ContactForm branches based on consent state: shows full form when consent is true/null/unhydrated, shows email alternative with re-consent link when consent is explicitly false. The useContactForm hook (which calls useGoogleReCaptcha) is only invoked inside ContactFormFull, which only renders when the GoogleReCaptchaProvider is mounted or when consent is undecided (safe — existing null-check handles this). FingerprintJS only runs at submit time inside the full form path. No cookie wall — email alternative is a real functional option.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. **Lint check:** `npm run lint` passes with no errors
2. **Build check:** `npm run build` succeeds without errors
3. **SCRP-01 (reCAPTCHA gating):** Providers.tsx has no GoogleReCaptchaProvider. Contact page conditionally mounts it only when hasConsented === true.
4. **SCRP-02 (FingerprintJS gating):** FingerprintJS.load() is only called inside handleSubmit in useContactForm, which is only called inside ContactFormFull, which only renders when consent is not false. When consent is false, NoConsentAlternative renders instead — no FingerprintJS code path is reachable.
5. **SCRP-03 (Form replacement):** When hasConsented === false, ContactForm renders NoConsentAlternative with: (a) email link to hello@streetfeastapp.com, (b) clearConsent button to re-open cookie banner, (c) Terms of Service link.
6. **No crashes:** useGoogleReCaptcha is only called inside ContactFormFull, which renders within GoogleReCaptchaProvider (when consent is true) or outside it (when consent is null/unhydrated — the existing executeRecaptcha null-check in useContactForm handles this gracefully by showing error status).
</verification>

<success_criteria>
- `npm run lint` passes
- `npm run build` succeeds
- Providers.tsx contains no GoogleReCaptchaProvider import or usage
- Contact page conditionally mounts GoogleReCaptchaProvider only when isHydrated && hasConsented === true
- ContactForm renders NoConsentAlternative when hasConsented === false (with email link and re-consent button)
- ContactForm renders ContactFormFull when hasConsented is true, null, or before hydration
- No useGoogleReCaptcha hook is called outside a component that can render without the provider
</success_criteria>

<output>
After completion, create `.planning/phases/03-script-blocking-form-gating/03-01-SUMMARY.md`
</output>
